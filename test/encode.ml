(* reed-solomon encoder testbench. 
 * 
 * compares parity generated by hardware to the software reference for
 * a bunch of messages
 *)

open HardCaml.Api
open HardCamlWaveLTerm.Api

module Sw = Reedsolomon.Codec.BBCTest
module Hw = HardCamlReedsolomon.Codec.Make(Sw.Gp)(Sw.Rp)
module G = Interface.Gen(Hw.Encoder.I)(Hw.Encoder.O)

let cfg = 
  let open Waveterm_waves in
  let open Hw.Encoder in
  (List.map  (fun n -> n, B) ["clock"; "clear"]) @
  (I.(to_list (map2 (fun (n,_) b -> n, b) t {enable=B; ctrl=B; d=U}))) @
  (O.(to_list (map (fun (n,_) -> n, U) t))) 

let test () = 
  let open Hw.Encoder.I in
  let open Hw.Encoder.O in

  let circ, sim, i, o = G.make "rs_encode" Hw.Encoder.f in
  let () = if false then HardCaml.Rtl.Verilog.write print_string circ in
  let sim, waves = Waveterm_sim.wrap ~cfg sim in

  let rev a = let len = Array.length a in Array.init len (fun i -> a.(len - i - 1)) in
  let parity_sw data = rev (Sw.R.R.slice  (Sw.R.parity (rev data)) (2*Sw.Rp.t-1)) in

  let parity_tb data = 
    i.ctrl := B.gnd;
    for j=0 to Sw.Rp.k-1 do
      i.d := B.consti 4 data.(j);
      Cs.cycle sim;
    done;
    i.ctrl := B.vdd;
    Array.init (Sw.Rp.t*2) (fun _ -> let r = B.to_int !(o.q) in Cs.cycle sim; r) 
  in

  Cs.reset sim;
  i.enable := B.vdd;
  (Cs.in_port sim "clear") := B.vdd;
  Cs.cycle sim;
  (Cs.in_port sim "clear") := B.gnd;
  (* compare 100 messages back to back *)
  for j=0 to 100 do
    let data = Array.init Sw.Rp.k (fun j -> Random.int 16) in
    if parity_tb data <> parity_sw data then begin
      Array.iter (Printf.printf "%i ") data; Printf.printf "\n";
      Array.iter (Printf.printf "%i ") (parity_tb data); Printf.printf "\n";
      Array.iter (Printf.printf "%i ") (parity_sw data); Printf.printf "\n";
    end
  done;
  Lwt_main.run (Waveterm_ui.run Waveterm_waves.({ cfg=default; waves }))

let () = test ()

