(* reed-solomon encoder testbench. 
 * 
 * compares parity generated by hardware to the software reference for
 * a bunch of messages
 *)

open HardCaml.Api
open HardCamlWaveLTerm.Api

module Sw = Reedsolomon.Codec.BBCTest
module Hw = HardCamlReedsolomon.Codec.Make(Sw.Gp)(Sw.Rp)
module G = Interface.Gen(Hw.Encoder.I)(Hw.Encoder.O)

(* configure waveform display *)
let cfg = 
  let open Waveterm_waves in
  let open Hw.Encoder in
  (List.map  (fun n -> n, B) ["clock"; "clear"]) @
  (I.(to_list (map2 (fun (n,_) b -> n, b) t {enable=B; ctrl=B; d=U}))) @
  (O.(to_list (map (fun (n,_) -> n, U) t))) 

let test () = 
  let open Hw.Encoder.I in
  let open Hw.Encoder.O in

  let circ, sim, i, o = G.make "rs_encode" Hw.Encoder.f in
  let () = if false then HardCaml.Rtl.Verilog.write print_string circ in
  let sim, waves = Waveterm_sim.wrap ~cfg sim in

  (* execute encoder *)
  let parity_tb data = 
    (* load data *)
    i.ctrl := B.gnd;
    for j=0 to Sw.Rp.k-1 do
      i.d := B.consti 4 data.(j);
      Cs.cycle sim;
    done;
    (* read parity *)
    i.ctrl := B.vdd;
    Array.init (Sw.Rp.t*2) (fun _ -> let r = B.to_int !(o.q) in Cs.cycle sim; r) 
  in

  (* reset/clear and enable *)
  Cs.reset sim;
  i.enable := B.vdd;
  (Cs.in_port sim "clear") := B.vdd;
  Cs.cycle sim;
  (Cs.in_port sim "clear") := B.gnd;

  (* compare 100 messages back to back *)
  for j=0 to 100 do
    let data = Rsutil.message () in
    let parity_tb = parity_tb data in
    let parity_sw = Rsutil.parity data in
    if parity_tb <> parity_sw then begin
      Array.iter (Printf.printf "%i ") data; Printf.printf "\n";
      Array.iter (Printf.printf "%i ") parity_tb; Printf.printf "\n";
      Array.iter (Printf.printf "%i ") parity_sw; Printf.printf "\n";
    end
  done;
  Lwt_main.run (Waveterm_ui.run Waveterm_waves.({ cfg=default; waves }))

let () = test ()

